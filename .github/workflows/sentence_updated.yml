name: Sentence Level Transcription

on:
  workflow_run:
    workflows: ["Transcript"]
    types:
      - completed
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'Visuals/**'
      - 'Trans/**'

permissions:
  contents: write

jobs:
  generate-transcription:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name != 'workflow_run' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Generate sentence-level transcription
        run: |
          python3 << 'EOF'
          import json
          import os
          import re
          from datetime import datetime
          from difflib import SequenceMatcher

          def clean_word(word):
              word = re.sub(r"[^\w\s']", '', word.lower())
              word = word.replace("'s", "").replace("n't", "nt").replace("'re", "are").replace("'ll", "will").replace("'ve", "have").replace("'d", "would").replace("'m", "am")
              return word

          def is_similar(word1, word2, threshold=0.7):
              return SequenceMatcher(None, word1, word2).ratio() >= threshold

          def find_sentence_timing(sentence_text, word_segments, start_idx):
              sentence_words = [clean_word(w) for w in sentence_text.split() if clean_word(w)]
              if not sentence_words:
                  return None, start_idx

              matched_indices = []
              search_ptr = start_idx
              
              # Try to find words sequentially, but allow for missing words in the transcript
              for target in sentence_words:
                  search_end = min(search_ptr + 40, len(word_segments))
                  for i in range(search_ptr, search_end):
                      if clean_word(word_segments[i]["word"]) == target or is_similar(clean_word(word_segments[i]["word"]), target):
                          matched_indices.append(i)
                          search_ptr = i + 1
                          break
              
              if len(matched_indices) >= 1:
                  # If we only matched a few words, ensure they aren't too far apart
                  first = matched_indices[0]
                  last = matched_indices[-1]
                  
                  # Duration check (sanity)
                  if word_segments[last]["end"] - word_segments[first]["start"] > 15:
                      # If it's too long, it's likely a bad match, just take the first word's area
                      last = first

                  return {
                      "start": round(word_segments[first]["start"], 3),
                      "end": round(word_segments[last]["end"], 3)
                  }, last + 1
              
              return None, start_idx

          def main():
              trans_path = "Trans/transcription.json"
              visuals_path = "Visuals/visuals.json"
              
              if not os.path.exists(trans_path) or not os.path.exists(visuals_path):
                  print("Missing source files")
                  return

              with open(trans_path, 'r') as f:
                  trans_data = json.load(f)
              with open(visuals_path, 'r') as f:
                  visuals = json.load(f)

              # Flatten words from all segments
              all_words = []
              for seg in trans_data.get("segments", []):
                  all_words.extend(seg.get("words", []))

              results = []
              current_word_idx = 0

              for item in visuals:
                  timing, next_idx = find_sentence_timing(item["sentence"], all_words, current_word_idx)
                  
                  if timing:
                      current_word_idx = next_idx
                      results.append({
                          "id": f"i{item['number']}",
                          "number": item["number"],
                          "sentence": item["sentence"],
                          "start": timing["start"],
                          "end": timing["end"],
                          "duration": round(timing["end"] - timing["start"], 3)
                      })
                  else:
                      # Fallback: assign tiny duration at current pointer so we don't crash
                      last_time = all_words[current_word_idx]["start"] if current_word_idx < len(all_words) else 0
                      results.append({
                          "id": f"i{item['number']}",
                          "number": item["number"],
                          "sentence": item["sentence"],
                          "start": last_time,
                          "end": last_time + 0.1,
                          "duration": 0.1
                      })

              output = {
                  "metadata": {
                      "created_at": datetime.utcnow().isoformat() + "Z",
                      "total_sentences": len(results),
                      "source_files": {"visuals": visuals_path, "transcription": trans_path}
                  },
                  "sentence_transcriptions": results
              }

              os.makedirs("Edits", exist_ok=True)
              with open("Edits/edit.json", "w", encoding="utf-8") as f:
                  json.dump(output, f, indent=2, ensure_ascii=False)

          if __name__ == "__main__":
              main()
          EOF

      - name: Configure Git
        run: |
          git config --global user.name "intellectra9"
          git config --global user.email "intellectra9@outlook.com"

      - name: Commit and push transcription file
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          git stash --include-untracked
          git pull origin main --rebase || echo "No rebase needed"
          git stash pop || true
          git add Edits/edit.json
          timestamp=$(TZ="Asia/Kolkata" date +"%Y-%m-%d %H:%M:%S IST")
          git commit -m "ðŸ”„ Fixed sentence transcription: ${timestamp}" || echo "No changes to commit"
          git push https://x-access-token:${GH_PAT}@github.com/${{ github.repository }}.git HEAD:main

